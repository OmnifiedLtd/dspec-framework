"use strict";(self.webpackChunkdocusaurus_tailwind_shadcn_template=self.webpackChunkdocusaurus_tailwind_shadcn_template||[]).push([["5068"],{93710:function(e,t,n){n.r(t),n.d(t,{metadata:()=>s,default:()=>h,frontMatter:()=>o,contentTitle:()=>i,toc:()=>c,assets:()=>l});var s=JSON.parse('{"id":"why-aggregates-not-at-level-0","title":"Why Aggregates not at Level-0","description":"- Aggregate = mechanism, not meaning. Aggregates (consistency groups) are design\u2011time choices for how you keep rules true. Level\u20110 defines which rules must be true and when (the consistency intent), not how.","source":"@site/docs/11-why-aggregates-not-at-level-0.md","sourceDirName":".","slug":"/why-aggregates-not-at-level-0","permalink":"/dspec-framework/docs/why-aggregates-not-at-level-0","draft":false,"unlisted":false,"editUrl":"https://github.com/OmnifiedLtd/dspec-framework/tree/main/docs/11-why-aggregates-not-at-level-0.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"layout":"default","title":"Why Aggregates not at Level-0","nav_order":12},"sidebar":"tutorialSidebar","previous":{"title":"Level-2 Implementation dspec","permalink":"/dspec-framework/docs/level-2-implementation-dspec"},"next":{"title":"Traceability & Governance","permalink":"/dspec-framework/docs/traceability-and-governance"}}'),r=n(74848),a=n(84429);let o={layout:"default",title:"Why Aggregates not at Level-0",nav_order:12},i="Why Aggregates Aren\u2019t Included at Level\u20110",l={},c=[];function d(e){let t={em:"em",h1:"h1",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"why-aggregates-arent-included-at-level0",children:"Why Aggregates Aren\u2019t Included at Level\u20110"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Aggregate = mechanism, not meaning."})," Aggregates (consistency groups) are ",(0,r.jsx)(t.strong,{children:"design\u2011time"})," choices for how you keep rules true. Level\u20110 defines ",(0,r.jsx)(t.em,{children:"which rules"})," must be true and ",(0,r.jsx)(t.em,{children:"when"})," (the ",(0,r.jsx)(t.strong,{children:"consistency intent"}),"), not how."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Premature boundaries distort models."})," Locking in boundaries before you know volumes, hotspots, and latency windows often couples the model to storage/memory limits."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"WBS alignment."})," Level\u20110 should define ",(0,r.jsx)(t.strong,{children:"What"})," and ",(0,r.jsx)(t.strong,{children:"Boundaries"})," as constraints on meaning (invariants and their strictness), letting later stages pick mechanisms. This preserves ",(0,r.jsx)(t.strong,{children:"constructive constraint"})," and avoids over\u2011specifying early."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Rule of thumb:"})," Decide boundaries only after you know (1) the invariants, (2) the ",(0,r.jsx)(t.strong,{children:"moments of truth"})," where they must hold, and (3) the scale/latency drivers. Then map each invariant to a mechanism at Level\u20111."]})]})}function h(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},84429:function(e,t,n){n.d(t,{R:()=>o,x:()=>i});var s=n(96540);let r={},a=s.createContext(r);function o(e){let t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);