"use strict";(self.webpackChunkdocusaurus_tailwind_shadcn_template=self.webpackChunkdocusaurus_tailwind_shadcn_template||[]).push([["3961"],{94796:function(e,n,t){t.r(n),t.d(n,{metadata:()=>s,default:()=>h,frontMatter:()=>a,contentTitle:()=>o,toc:()=>c,assets:()=>l});var s=JSON.parse('{"id":"features","title":"Features","description":"In the DSpec framework, a Feature is the primary unit of specification and delivery. It represents a distinct slice of functionality that provides value to a user or system.","source":"@site/docs/features.md","sourceDirName":".","slug":"/features","permalink":"/dspec-framework/docs/features","draft":false,"unlisted":false,"editUrl":"https://github.com/OmnifiedLtd/dspec-framework/tree/main/docs/features.md","tags":[],"version":"current","frontMatter":{"layout":"default","title":"Features"},"sidebar":"tutorialSidebar","previous":{"title":"Core Principles","permalink":"/dspec-framework/docs/core-principles"},"next":{"title":"Domain Models & Bounded Contexts","permalink":"/dspec-framework/docs/domain-models-and-bounded-contexts"}}'),i=t(74848),r=t(84429);let a={layout:"default",title:"Features"},o="Features",l={},c=[{value:"The Structure of a Feature",id:"the-structure-of-a-feature",level:2},{value:"Visualizing the Stack",id:"visualizing-the-stack",level:3},{value:"The Relationship: Features and Domain Models",id:"the-relationship-features-and-domain-models",level:2},{value:"&quot;Features sit on top of the Domain Model&quot;",id:"features-sit-on-top-of-the-domain-model",level:3},{value:"Atomic Features and Decomposition",id:"atomic-features-and-decomposition",level:2},{value:"1. Grouping Complex Requirements (within a single Feature)",id:"1-grouping-complex-requirements-within-a-single-feature",level:3},{value:"2. Reuse and Dependencies (across multiple Features)",id:"2-reuse-and-dependencies-across-multiple-features",level:3},{value:"Benefits of this Approach (vs. Formal &quot;Subfeatures&quot;)",id:"benefits-of-this-approach-vs-formal-subfeatures",level:3},{value:"Composition Patterns: Containers &amp; Capabilities",id:"composition-patterns-containers--capabilities",level:2},{value:"Frontend Example: The Dashboard (Composite UI)",id:"frontend-example-the-dashboard-composite-ui",level:3},{value:"Backend Example: Bulk Sync (Orchestration)",id:"backend-example-bulk-sync-orchestration",level:3},{value:"The Three Levels of a Feature",id:"the-three-levels-of-a-feature",level:2},{value:"1. Level-0: The Feature Spec (Intent)",id:"1-level-0-the-feature-spec-intent",level:3},{value:"2. Level-1: The Design Spec (Architecture)",id:"2-level-1-the-design-spec-architecture",level:3},{value:"3. Level-2: The Implementation Spec (Code)",id:"3-level-2-the-implementation-spec-code",level:3}];function d(e){let n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"features",children:"Features"})}),"\n",(0,i.jsxs)(n.p,{children:["In the DSpec framework, a ",(0,i.jsx)(n.strong,{children:"Feature"})," is the primary unit of specification and delivery. It represents a distinct slice of functionality that provides value to a user or system."]}),"\n",(0,i.jsxs)(n.p,{children:["A Feature is not a single document; it is a vertical slice of functionality underpinned by a ",(0,i.jsx)(n.strong,{children:"Domain Model"})," and defined progressively through ",(0,i.jsx)(n.strong,{children:"three levels of specification"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"To manifest a feature deterministically and unambiguously, it must be fully specified across all three levels."}),"\n",(0,i.jsx)(n.h2,{id:"the-structure-of-a-feature",children:"The Structure of a Feature"}),"\n",(0,i.jsx)(n.p,{children:"A complete DSpec Feature is composed of:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"The Domain Model (Foundation):"})," Defines the vocabulary, invariants, and rules."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Level-0 Spec (Intent):"})," Defines ",(0,i.jsx)(n.em,{children:"what"})," the feature does (User Intent & Outcomes)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Level-1 Spec (Design):"})," Defines ",(0,i.jsx)(n.em,{children:"how"})," the system is architected to handle it (Commands & Consistency)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Level-2 Spec (Implementation):"})," Defines ",(0,i.jsx)(n.em,{children:"how"})," it is coded (Tables, Classes, Functions)."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"visualizing-the-stack",children:"Visualizing the Stack"}),"\n",(0,i.jsx)(n.mermaid,{value:"graph TD\n    L0[Level-0 Spec<br/>User Intent] --\x3e|Refines| L1[Level-1 Spec<br/>Architecture]\n    L1 --\x3e|Refines| L2[Level-2 Spec<br/>Code]\n    L0 --\x3e|Uses Vocabulary From| DM[Domain Model]\n    L1 --\x3e|Uses Vocabulary From| DM\n    L2 --\x3e|Uses Vocabulary From| DM"}),"\n",(0,i.jsx)(n.h2,{id:"the-relationship-features-and-domain-models",children:"The Relationship: Features and Domain Models"}),"\n",(0,i.jsx)(n.p,{children:"A common pitfall in software specification is mixing definitions with behavior. DSpec strictly separates these:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Domain Model"})," is the foundation. It defines the ",(0,i.jsx)(n.strong,{children:"Ubiquitous Language"}),": the domain concepts, definitions, and invariant rules that are true regardless of any specific user workflow."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Example:"}),' "A ',(0,i.jsx)(n.code,{children:"BankAccount"}),' must have a non-negative balance."']}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The Feature"})," is the application of that model. It orchestrates the domain elements to achieve a specific outcome."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"Example:"}),' "User transfers money." This feature relies on the concept of ',(0,i.jsx)(n.code,{children:"BankAccount"})," defined in the Domain Model but focuses on the ",(0,i.jsx)(n.em,{children:"flow"})," of the transfer."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"features-sit-on-top-of-the-domain-model",children:'"Features sit on top of the Domain Model"'}),"\n",(0,i.jsx)(n.p,{children:"You cannot write a concise, readable Feature spec without a Domain Model. The Domain Model acts as the dictionary. If your Feature spec is cluttered with definitions of data structures or validation rules, it\u2019s a sign that those belong in the Domain Model."}),"\n",(0,i.jsx)(n.h2,{id:"atomic-features-and-decomposition",children:"Atomic Features and Decomposition"}),"\n",(0,i.jsxs)(n.p,{children:["A core principle of DSpec is that Features are ",(0,i.jsx)(n.strong,{children:"atomic"}),". This means a Feature should represent the smallest unit of functionality that provides distinct value to a user or system and can be independently delivered, verified, and reasoned about."]}),"\n",(0,i.jsx)(n.p,{children:'The ideal Feature is small and focused. If a Feature grows too large or encompasses disparate concerns, it can be a "smell" indicating that it needs to be broken down. DSpec provides two primary mechanisms for this decomposition:'}),"\n",(0,i.jsx)(n.h3,{id:"1-grouping-complex-requirements-within-a-single-feature",children:"1. Grouping Complex Requirements (within a single Feature)"}),"\n",(0,i.jsxs)(n.p,{children:["Even an atomic Feature can involve a complex set of requirements or steps. To maintain readability and organization within a single Level-0 spec, you can use ",(0,i.jsx)(n.strong,{children:"grouping"})," for ",(0,i.jsx)(n.code,{children:"scope"})," items. This allows you to logically categorize related requirements without breaking the Feature into separate entities."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"When to use:"})," When distinct parts of the user intent are tightly coupled and do not provide standalone value outside the current Feature. The Feature as a whole remains the single unit of delivery."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example:"})," A ",(0,i.jsx)(n.code,{children:"feature.order-checkout"}),' might group its scope items into "Payment Processing Steps" and "Order Fulfillment Steps."']}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# In feature.order-checkout (Level-0)\nscope:\n  in:\n    - id: group.payment\n      name: "Payment Processing"\n      description: "Steps involved in handling customer payment."\n      items:\n        - id: scope.payment.authorize\n          statement: "Authorize customer\'s credit card."\n        - id: scope.payment.capture\n          statement: "Capture funds for the order."\n    - id: group.fulfillment\n      name: "Order Fulfillment"\n      description: "Steps to prepare and ship the order."\n      items:\n        - id: scope.fulfillment.allocate-inventory\n          statement: "Allocate inventory for ordered items."\n        - id: scope.fulfillment.create-shipment\n          statement: "Create shipment request."\n'})}),"\n",(0,i.jsx)(n.h3,{id:"2-reuse-and-dependencies-across-multiple-features",children:"2. Reuse and Dependencies (across multiple Features)"}),"\n",(0,i.jsx)(n.p,{children:"If a distinct piece of functionality provides value on its own and can be utilized by multiple other Features, it should be defined as its own separate Feature. This allows for reuse and clear dependency tracking."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"When to use:"}),' When a component or capability has its own lifecycle, business rules (Invariants), and can function independently. It\'s a "child" feature that other "parent" features consume.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example:"})," Both ",(0,i.jsx)(n.code,{children:"feature.order-checkout"})," and ",(0,i.jsx)(n.code,{children:"feature.subscription-renewal"})," might need to process payments. Instead of duplicating payment logic in each, ",(0,i.jsx)(n.code,{children:"feature.payment-processing"})," can be a reusable Feature."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# In feature.order-checkout (Level-0)\ndependencies:\n  upstream:\n    - 'feature.payment-processing'\n\n# In feature.subscription-renewal (Level-0)\ndependencies:\n  upstream:\n    - 'feature.payment-processing'\n"})}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-this-approach-vs-formal-subfeatures",children:'Benefits of this Approach (vs. Formal "Subfeatures")'}),"\n",(0,i.jsx)(n.p,{children:'By using grouping for internal organization and dependencies for reuse, DSpec avoids the need for a formal "Subfeature" entity. This provides several key benefits:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clarity and Simplicity:"})," The Feature remains the single, atomic unit of value, preventing ambiguous states or partial deliveries."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reduced Complexity:"}),' Avoids the "Russian Doll" problem of nested features, where defining boundaries, ownership, and verification becomes increasingly difficult.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Strong Traceability:"})," ",(0,i.jsx)(n.code,{children:"dependencies"})," explicitly map relationships between independent Features, while grouping clarifies the internal structure of a single Feature."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Independent Deliverability:"})," Each Feature can theoretically be built and deployed on its own, fostering modularity."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This strategy ensures that the framework remains lightweight and focused on clear, declarative specifications, supporting both human understanding and AI agent consumption."}),"\n",(0,i.jsx)(n.h2,{id:"composition-patterns-containers--capabilities",children:"Composition Patterns: Containers & Capabilities"}),"\n",(0,i.jsxs)(n.p,{children:["A powerful pattern for structuring complex systems in DSpec is to distinguish between ",(0,i.jsx)(n.strong,{children:"Capability Features"})," (which own logic) and ",(0,i.jsx)(n.strong,{children:"Container Features"})," (which orchestrate or display capabilities)."]}),"\n",(0,i.jsx)(n.p,{children:"This pattern resolves common dilemmas in both Frontend and Backend architecture."}),"\n",(0,i.jsx)(n.h3,{id:"frontend-example-the-dashboard-composite-ui",children:"Frontend Example: The Dashboard (Composite UI)"}),"\n",(0,i.jsxs)(n.p,{children:['A Dashboard is often one large "page" visually, but structurally it is a composition of distinct functionalities. Instead of defining all logic inside ',(0,i.jsx)(n.code,{children:"feature.dashboard"}),", treat the Dashboard as a ",(0,i.jsx)(n.strong,{children:"Container"})," that aggregates other ",(0,i.jsx)(n.strong,{children:"Capability"})," features."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"feature.view-transactions"})," (Capability): Owns the logic for listing, filtering, and sorting transactions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"feature.transfer-money"})," (Capability): Owns the form validation, API calls, and rules for moving funds."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"feature.dashboard"})," (Container): Owns the layout and orchestration."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# feature.dashboard (Level-0)\nmeta:\n  id: feature.dashboard\n  name: User Dashboard\n  # ...\n\nintent: "Provide a high-level overview of financial health and quick access to common actions."\n\ndependencies:\n  upstream:\n    - feature.view-transactions  # Reusing the transaction list capability\n    - feature.transfer-money     # Reusing the transfer form capability\n\nscope:\n  in:\n    - id: scope.layout\n      statement: "Aggregate summary views from upstream features into a single responsive grid."\n    - id: scope.interactions\n      statement: "Clicking \'See All\' on Transactions widget navigates to full Transaction history."\n'})}),"\n",(0,i.jsx)(n.h3,{id:"backend-example-bulk-sync-orchestration",children:"Backend Example: Bulk Sync (Orchestration)"}),"\n",(0,i.jsx)(n.p,{children:'Similarly, a backend process like "Sync ERP to Shopify" can be decomposed. If you implement it as one giant script, it becomes hard to maintain. Instead, break it down:'}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"feature.sync-product"})," (Capability): Owns the logic to map ",(0,i.jsx)(n.em,{children:"one"})," ERP product to Shopify, handle API rate limits, and validate data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"feature.erp-bulk-sync"})," (Container): Owns the logic to iterate through the ERP catalog, manage job state, and call the single-product sync."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'# feature.erp-bulk-sync (Level-0)\nmeta:\n  id: feature.erp-bulk-sync\n  name: Bulk ERP Product Synchronization\n  # ...\n\nintent: "Ensure the entire Shopify catalog matches the ERP system state on a nightly basis."\n\ndependencies:\n  upstream:\n    - feature.sync-product  # Reusing the logic to sync a single item\n\nscope:\n  in:\n    - id: scope.iteration\n      statement: "Iterate through all modified ERP products."\n    - id: scope.orchestration\n      statement: "Invoke feature.sync-product for each item, aggregating success/failure results."\n'})}),"\n",(0,i.jsxs)(n.p,{children:["By using ",(0,i.jsx)(n.strong,{children:"Composition"}),", you ensure that complex logic (like validation or mapping) is defined in exactly one place (the Capability Feature) and reused wherever it is needed (Dashboards, Bulk Jobs, Webhooks, etc.)."]}),"\n",(0,i.jsx)(n.h2,{id:"the-three-levels-of-a-feature",children:"The Three Levels of a Feature"}),"\n",(0,i.jsx)(n.p,{children:"While a Feature starts at Level-0, it is not complete until it has been constrained through all layers."}),"\n",(0,i.jsx)(n.h3,{id:"1-level-0-the-feature-spec-intent",children:"1. Level-0: The Feature Spec (Intent)"}),"\n",(0,i.jsxs)(n.p,{children:["Focuses entirely on the ",(0,i.jsx)(n.strong,{children:"User Intent"})," and the ",(0,i.jsx)(n.strong,{children:"System Consequence"})," (Events)."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Intent:"})," What is the user trying to do? (e.g., ",(0,i.jsx)(n.code,{children:"PlaceOrder"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Preconditions:"})," What must be true for this to happen? (e.g., ",(0,i.jsx)(n.code,{children:"UserIsLoggedIn"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Outcome:"})," What facts are recorded in the system history? (e.g., ",(0,i.jsx)(n.code,{children:"OrderPlaced"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2-level-1-the-design-spec-architecture",children:"2. Level-1: The Design Spec (Architecture)"}),"\n",(0,i.jsxs)(n.p,{children:["Focuses on the ",(0,i.jsx)(n.strong,{children:"Mechanisms"})," and ",(0,i.jsx)(n.strong,{children:"Consistency"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Commands:"})," How does the user trigger the intent? (e.g., ",(0,i.jsx)(n.code,{children:"POST /orders"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistency:"})," Is this strongly consistent (ACID) or eventually consistent?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Components:"})," Which system components handle the logic?"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"3-level-2-the-implementation-spec-code",children:"3. Level-2: The Implementation Spec (Code)"}),"\n",(0,i.jsxs)(n.p,{children:["Focuses on the ",(0,i.jsx)(n.strong,{children:"Technology"})," and ",(0,i.jsx)(n.strong,{children:"Storage"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Schema:"})," Exact SQL tables or JSON structures."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Classes:"})," Specific class names and method signatures."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code:"})," The actual implementation details."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By strictly layering these concerns, the DSpec framework ensures that business intent (L0) remains stable even if the implementation (L2) changes."})]})}function h(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},84429:function(e,n,t){t.d(n,{R:()=>a,x:()=>o});var s=t(96540);let i={},r=s.createContext(i);function a(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);